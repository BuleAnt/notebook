## 模块

导入( import )：把其他模块中属性附加到你的模块中的操作。

**模块**：自我包含有组织的代码片段。

一个文件被看作是一个独立模块，一个模块也被看作一个文件，

模块的文件名就是模块的名字加上扩展名.py,  在Python中导入的是模块或模块属性。

名称空间：一个名称到对象的关系映射集合。完整授权名称，通过句点属性标识指定了各自的名称空间。



**搜索路径和路径搜索：**

- 路径搜索：在文件系统“预定义区域”中查找mymodule.py 文件（导入mymodule）【查找某个文件的操作】, 预定义区域是你的Python搜索路径的集合。
- 搜索路径：去查找一组目录。

搜索路径保存在 sys模块的sys.path变量中, 可以使用 sys.path.append() 方法追加指定目录，用于导入指定目录下的模块。

sys.modules 可以找到当前导入了那些模块，以及对应的模块位置。



#### 名称空间

名称空间：名称(标识符)到对象的映射，向名称空间添加名称的操作过程涉及绑定标识符到指定对象的操作。

​		改变一个名字的绑定叫做重新绑定，删除一个名字叫做解除绑定。

局部名称空间、全局名称空间、内建名称空间。 局部名称空间在执行期间是不断变化的，从名称空间访问这些名字依赖于它们的加载顺序。

Python 解析器加载顺序，内建名称空间，模块的全局名称空间。

**内建名称空间**：由`__builtins__`模块中的名字构成。

**模块的全局名称空间**：在模块执行后变为活动名称空间

> `__builtins__`模块和 `__builtin__`模块不能混淆，
>
> `__builtins__`模块中包含内建名称空间中内建名字的集合。其中大多数来自`__builtin__`模块，该模块包含内建函数，异常以及其他属性。

在执行期间调用了一个函数，将创建出第三个名称空间，局部名称空间。

通过globals() 和 locals() 内建函数判断某一名字属于哪个名称空间。

globals() ：返回调用者全局名称空间字典，函数可访问的全局名称。

locals(): 返回调用者局部名称空间字典，函数执行时定义的所有名字。



名称查找顺序：局部名称空间  >> 全局名称空间 >> 内建名称空间

遮蔽效应：局部名称空间中找到的名字回隐藏全局或者内建名称空间的对应对象。

可以把想要的东西放入一个名称空间里。如下：

```
class testDevice(object):
	pass
bag = testDevice()
bag.x = 100
bag.y = 200
```



### 导入模块

**import 语句**

语法： ***import module1[, module2[,… moduleN]]***

> 推荐模块导入顺序：
>
> - Python 标准库模块
> - Python 第三方模块
> - 应用程序自定义模块
>
> 如果在一个模块顶层导入，那么作用域就是全局的。
>
> 如果在函数中导入，那么它的作用域是局部的。



**from-import 语句**

语法：**from** module **import** name1[, name2[, … nameN]]

将指定名称导入到当前作用域，

**as**别名



### 模块导入的特性

**载入时执行模块**

加载模块会导致模块被“执行”， 被导入模块的顶层代码将直接执行。

​	包括：设定全局变量以及类和函数的声明，有检查`__name__`操作，也将被执行。

只把函数和模块定义防盗模块的顶层是良好的模块编程习惯。

**导入和加载**

一个模块只被加载一次，无论悲导入多少次，只在第一次导入时加载。



### 包

包是一个有层次的文件目录结构，定义了由模块和子包组成的Python 应用程序执行环境。



**绝对导入**：名字必须通过Python路径（sys.path 或是 PYTHONPATH）来访问，  import 语句



**相对导入**：只应用于 from 中

​	语法的第一部分是一个句点，表示相对导入，之后的其他附加句点代表当前from 起始查找位置后的一个级别。

阻止属性被导入，在不想被导入的属性名称加一个下滑线(_)

显示导入某个属性，这个属性就无法隐藏了。（import foo._bar）



​	